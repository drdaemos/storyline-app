from pydantic import BaseModel, Field

from .character import Character, PartialCharacter


class CharacterSummary(BaseModel):
    """Summary model for character listing with minimal data."""

    id: str = Field(..., description="Character ID")
    name: str = Field(..., description="Character name")
    tagline: str = Field(..., description="Character tagline/description")


class CreateCharacterRequest(BaseModel):
    """Request model for creating a character card."""

    data: Character | str = Field(..., description="Either structured character data or freeform YAML text")
    is_yaml_text: bool = Field(False, description="Set to true if 'data' contains freeform YAML text")
    is_persona: bool = Field(False, description="Set to true if this character is a persona (user character)")


class CreateCharacterResponse(BaseModel):
    """Response model for character creation."""

    message: str
    character_filename: str


class InteractRequest(BaseModel):
    character_name: str = Field(..., min_length=1, description="Name of the character to interact with")
    user_message: str = Field(..., min_length=1, description="User's message to the character")
    session_id: str | None = Field(None, description="Optional session ID for conversation continuity")
    processor_type: str = Field("google", description="AI processor type (google, openai, cohere, etc.)")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type to use if primary fails")
    persona_id: str | None = Field(None, description="Optional persona character ID to use as the user's representation")


class SessionInfo(BaseModel):
    session_id: str
    character_name: str
    message_count: int
    last_message_time: str
    last_character_response: str | None = None


class SessionMessage(BaseModel):
    role: str
    content: str
    created_at: str


class SessionDetails(BaseModel):
    session_id: str
    character_name: str
    message_count: int
    last_messages: list[SessionMessage]
    last_message_time: str


class HealthStatus(BaseModel):
    status: str
    conversation_memory: str
    summary_memory: str
    details: dict[str, str] | None = None


class ErrorResponse(BaseModel):
    error: str
    detail: str


class ThinkingEvent(BaseModel):
    type: str = "thinking"
    stage: str = Field(..., description="Current processing stage: 'summarizing', 'deliberating', 'responding'")


class StreamEvent(BaseModel):
    type: str = Field(..., description="Event type: 'chunk', 'session', 'error', 'complete', 'thinking'")
    # Optional fields for different event types
    content: str | None = None
    session_id: str | None = None
    error: str | None = None
    full_response: str | None = None
    message_count: int | None = None
    stage: str | None = None  # For thinking events


class GenerateCharacterRequest(BaseModel):
    """Request model for generating a character with AI assistance."""

    partial_character: dict[str, str | list[str] | dict[str, str] | None] = Field(default_factory=dict, description="Partial character data with optional fields to be filled by AI")
    processor_type: str = Field(default="claude", description="AI processor type to use for generation (claude, openai, cohere, etc.)")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type to use if primary fails")


class GenerateCharacterResponse(BaseModel):
    """Response model for character generation."""

    character: Character = Field(..., description="Complete generated character")
    generated_fields: list[str] = Field(..., description="List of fields that were generated by AI")


class Scenario(BaseModel):
    """Model for a scenario with a description."""

    summary: str = Field(..., min_length=1, description="Short engaging, striking name for the scenario (take inspiration from series or book chapter titles)")
    intro_message: str = Field(..., min_length=1, description="Complete introductory message to set the scene in the role-play chat")
    narrative_category: str = Field(..., min_length=1, description="Short label for both the genre and tone of the scenario + the level of twistedness of the story")


class GenerateScenariosRequest(BaseModel):
    """Request model for generating scenario intros for a character."""

    character_name: str = Field(..., min_length=1, description="Name/ID of the character from the registry")
    count: int = Field(default=3, ge=1, le=10, description="Number of scenario intros to generate (1-10)")
    mood: str = Field(default="normal", description="Level of spiciness/twistedness of the scenarios: normal, spicy, dark, unhinged, mysterious, comedic, dramatic, gritty, philosophical, chaotic")
    persona_id: str | None = Field(None, description="Optional persona ID to use as user context for scenario generation")
    processor_type: str = Field(default="claude", description="AI processor type to use for generation (claude, openai, cohere, etc.)")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type to use if primary fails")


class GenerateScenariosResponse(BaseModel):
    """Response model for scenario generation."""

    character_name: str = Field(..., description="Name of the character the scenarios were generated for")
    scenarios: list[Scenario] = Field(..., description="List of generated scenarios")


class StartSessionRequest(BaseModel):
    """Request model for starting a session with a scenario."""

    character_name: str = Field(..., min_length=1, description="Name of the character")
    intro_message: str = Field(..., min_length=1, description="The scenario intro message")
    persona_id: str | None = Field(None, description="Optional persona ID to use as user context")
    processor_type: str = Field(default="claude", description="AI processor type")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type")


class StartSessionResponse(BaseModel):
    """Response model for starting a session."""

    session_id: str = Field(..., description="The created session ID")


class ChatMessageModel(BaseModel):
    """Model for a chat message in character creation."""

    author: str = Field(..., description="Author of the message (User or AI)")
    content: str = Field(..., description="Content of the message")
    is_user: bool = Field(..., description="Whether this message is from the user")


class CharacterCreationRequest(BaseModel):
    """Request model for interactive character creation with AI assistant."""

    user_message: str = Field(..., min_length=1, description="User's message describing the character")
    current_character: PartialCharacter = Field(default_factory=dict, description="Current partial character data")
    conversation_history: list[ChatMessageModel] = Field(default_factory=list, description="Previous conversation messages for context")
    processor_type: str = Field(default="claude", description="AI processor type to use")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type")


class CharacterCreationStreamEvent(BaseModel):
    """Stream event for character creation."""

    type: str = Field(..., description="Event type: 'message', 'update', 'complete', 'error'")
    message: str | None = Field(None, description="AI message chunk to show in chat")
    updates: PartialCharacter | None = Field(None, description="Updated character state with current values")
    error: str | None = Field(None, description="Error message if type is 'error'")


class ScenarioGenerationStreamEvent(BaseModel):
    """Stream event for scenario generation."""

    type: str = Field(..., description="Event type: 'chunk', 'scenario', 'complete', 'error'")
    chunk: str | None = Field(None, description="Text chunk from the AI generation (raw XML)")
    scenario: Scenario | None = Field(None, description="Completed scenario object")
    error: str | None = Field(None, description="Error message if type is 'error'")
