from pydantic import BaseModel, Field

from .character import Character, PartialCharacter


class CharacterSummary(BaseModel):
    """Summary model for character listing with minimal data."""

    id: str = Field(..., description="Character ID")
    name: str = Field(..., description="Character name")
    tagline: str = Field(..., description="Character tagline/description")
    tags: list[str] = Field(default_factory=list, description="Character tags used for filtering and grouping")
    is_persona: bool = Field(default=False, description="Whether this summary represents a persona")


class CreateCharacterRequest(BaseModel):
    """Request model for creating a character card."""

    data: Character | str = Field(..., description="Either structured character data or freeform YAML text")
    is_yaml_text: bool = Field(False, description="Set to true if 'data' contains freeform YAML text")
    is_persona: bool = Field(False, description="Set to true if this character is a persona (user character)")


class CreateCharacterResponse(BaseModel):
    """Response model for character creation."""

    message: str
    character_filename: str


class InteractRequest(BaseModel):
    character_name: str = Field(..., min_length=1, description="Name of the character to interact with")
    user_message: str = Field(..., min_length=1, description="User's message to the character")
    session_id: str = Field(..., min_length=1, description="Session ID for simulation continuity")


class SessionInfo(BaseModel):
    session_id: str
    character_name: str
    message_count: int
    last_message_time: str
    last_character_response: str | None = None


class SessionMessage(BaseModel):
    role: str
    content: str
    created_at: str
    meta_text: str | None = None


class SessionDetails(BaseModel):
    session_id: str
    character_name: str
    message_count: int
    last_messages: list[SessionMessage]
    last_message_time: str
    suggested_actions: list[str] = Field(default_factory=list)


class HealthStatus(BaseModel):
    status: str
    conversation_memory: str
    summary_memory: str
    details: dict[str, str] | None = None


class ErrorResponse(BaseModel):
    error: str
    detail: str


class ThinkingEvent(BaseModel):
    type: str = "thinking"
    stage: str = Field(..., description="Current processing stage: 'summarizing', 'deliberating', 'responding'")


class StreamEvent(BaseModel):
    type: str = Field(..., description="Event type: 'chunk', 'session', 'error', 'complete', 'thinking'")
    # Optional fields for different event types
    content: str | None = None
    session_id: str | None = None
    error: str | None = None
    full_response: str | None = None
    message_count: int | None = None
    stage: str | None = None  # For thinking events
    suggested_actions: list[str] | None = None
    meta_text: str | None = None


class GenerateCharacterRequest(BaseModel):
    """Request model for generating a character with AI assistance."""

    partial_character: dict[str, str | list[str] | dict[str, str] | None] = Field(default_factory=dict, description="Partial character data with optional fields to be filled by AI")
    processor_type: str = Field(default="claude", description="AI processor type to use for generation (claude, openai, cohere, etc.)")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type to use if primary fails")


class GenerateCharacterResponse(BaseModel):
    """Response model for character generation."""

    character: Character = Field(..., description="Complete generated character")
    generated_fields: list[str] = Field(..., description="List of fields that were generated by AI")


class Scenario(BaseModel):
    """Model for a rich scenario with story development information."""

    # Core fields (used in both batch and interactive generation)
    summary: str = Field(..., min_length=1, description="Short engaging, striking name for the scenario (take inspiration from series or book chapter titles)")
    intro_message: str = Field(..., min_length=1, description="Complete introductory message to set the scene in the story")
    narrative_category: str = Field(..., min_length=1, description="Short label for both the genre and tone of the scenario + the level of twistedness of the story")

    # Character references (for interactive/stored scenarios)
    character_id: str = Field(default="", description="Main AI character ID this scenario is for")
    character_ids: list[str] = Field(default_factory=list, description="All character IDs participating in the scenario")
    character_tags: list[str] = Field(default_factory=list, description="Selected character tags used to resolve cast")
    ruleset_id: str = Field(default="everyday-tension", description="Ruleset ID controlling mechanics and scene schema")
    persona_id: str = Field(default="", description="User persona ID")
    world_lore_id: str | None = Field(default=None, description="Optional world lore asset ID")
    world_lore_tags: list[str] = Field(default_factory=list, description="Selected world lore tags used to resolve context")
    scene_seed: dict = Field(default_factory=dict, description="Ruleset-specific initial scene state overrides")

    # Location/Setting
    location: str = Field(default="", description="Where the scenario takes place")
    time_context: str = Field(default="", description="When/what situation (e.g., 'late evening', 'after the argument')")
    atmosphere: str = Field(default="", description="Detailed mood/atmosphere description")

    # Story structure
    plot_hooks: list[str] = Field(default_factory=list, description="Key tensions/conflicts to develop (2-4 items)")
    stakes: str = Field(default="", description="What's at risk in this scenario")
    character_goals: dict[str, str] = Field(default_factory=dict, description="{character_name: goal} - what each is trying to achieve")
    potential_directions: list[str] = Field(default_factory=list, description="Where the story could go (2-3 possibilities)")


class GenerateScenariosRequest(BaseModel):
    """Request model for generating scenario intros for a character."""

    character_name: str = Field(..., min_length=1, description="Name/ID of the character from the registry")
    count: int = Field(default=3, ge=1, le=10, description="Number of scenario intros to generate (1-10)")
    mood: str = Field(default="normal", description="Level of spiciness/twistedness of the scenarios: normal, spicy, dark, unhinged, mysterious, comedic, dramatic, gritty, philosophical, chaotic")
    persona_id: str | None = Field(None, description="Optional persona ID to use as user context for scenario generation")
    processor_type: str = Field(default="claude", description="AI processor type to use for generation (claude, openai, cohere, etc.)")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type to use if primary fails")


class GenerateScenariosResponse(BaseModel):
    """Response model for scenario generation."""

    character_name: str = Field(..., description="Name of the character the scenarios were generated for")
    scenarios: list[Scenario] = Field(..., description="List of generated scenarios")


class StartSessionRequest(BaseModel):
    """Request model for starting a session with a scenario."""

    character_name: str | None = Field(None, min_length=1, description="Name of the character (required when scenario_id is not provided)")
    scenario_id: str | None = Field(None, description="ID of a stored scenario to use")
    intro_message: str | None = Field(None, description="The scenario intro message (used if scenario_id not provided)")
    persona_id: str | None = Field(None, description="Optional persona id (required when no scenario_id)")
    ruleset_id: str = Field(default="everyday-tension", description="Ruleset ID (used when scenario_id is not provided)")
    world_lore_id: str = Field(default="default-world", description="World lore ID (used when scenario_id is not provided)")
    scene_seed: dict = Field(default_factory=dict, description="Scene state overrides (used when scenario_id is not provided)")
    small_model_key: str = Field(default="deepseek-v32", description="Small model taxonomy key (ruleset/reflection)")
    large_model_key: str = Field(default="claude-sonnet", description="Large model taxonomy key (narrator)")


class StartSessionResponse(BaseModel):
    """Response model for starting a session."""

    session_id: str = Field(..., description="The created session ID")


class ConfigureSessionModelsRequest(BaseModel):
    """Request model for updating per-session model keys."""

    small_model_key: str = Field(..., min_length=1, description="Small model taxonomy key")
    large_model_key: str = Field(..., min_length=1, description="Large model taxonomy key")


class ChatMessageModel(BaseModel):
    """Model for a chat message in character creation."""

    author: str = Field(..., description="Author of the message (User or AI)")
    content: str = Field(..., description="Content of the message")
    is_user: bool = Field(..., description="Whether this message is from the user")


class CharacterCreationRequest(BaseModel):
    """Request model for interactive character creation with AI assistant."""

    user_message: str = Field(..., min_length=1, description="User's message describing the character")
    current_character: PartialCharacter = Field(default_factory=dict, description="Current partial character data")
    conversation_history: list[ChatMessageModel] = Field(default_factory=list, description="Previous conversation messages for context")
    processor_type: str = Field(default="claude", description="AI processor type to use")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type")


class CharacterCreationStreamEvent(BaseModel):
    """Stream event for character creation."""

    type: str = Field(..., description="Event type: 'message', 'update', 'complete', 'error'")
    message: str | None = Field(None, description="AI message chunk to show in chat")
    updates: PartialCharacter | None = Field(None, description="Updated character state with current values")
    error: str | None = Field(None, description="Error message if type is 'error'")


class ScenarioGenerationStreamEvent(BaseModel):
    """Stream event for scenario generation."""

    type: str = Field(..., description="Event type: 'chunk', 'scenario', 'complete', 'error'")
    chunk: str | None = Field(None, description="Text chunk from the AI generation (raw XML)")
    scenario: Scenario | None = Field(None, description="Completed scenario object")
    error: str | None = Field(None, description="Error message if type is 'error'")


class PersonaSummary(BaseModel):
    """Summary of a persona for the AI to consider."""

    id: str = Field(..., description="Persona ID")
    name: str = Field(..., description="Persona name")
    tagline: str = Field(default="", description="Short persona description")
    personality: str = Field(default="", description="Personality traits")


class PartialScenario(BaseModel):
    """Partial scenario for incremental updates during interactive creation."""

    summary: str = Field(default="", description="Short engaging name for the scenario")
    intro_message: str = Field(default="", description="Complete introductory message to set the scene")
    narrative_category: str = Field(default="", description="Short label for genre and tone")
    character_id: str = Field(default="", description="Main AI character ID")
    character_ids: list[str] = Field(default_factory=list, description="All participating character IDs")
    character_tags: list[str] = Field(default_factory=list, description="Selected character tags")
    ruleset_id: str = Field(default="everyday-tension", description="Ruleset ID controlling mechanics and scene schema")
    persona_id: str | None = Field(None, description="Optional user persona ID")
    world_lore_id: str | None = Field(default=None, description="Optional world lore asset ID")
    world_lore_tags: list[str] = Field(default_factory=list, description="Selected world lore tags")
    scene_seed: dict = Field(default_factory=dict, description="Ruleset-specific initial scene state overrides")
    suggested_persona_id: str | None = Field(None, description="AI-suggested persona ID based on scenario direction")
    suggested_persona_reason: str = Field(default="", description="Reason for persona suggestion")
    location: str = Field(default="", description="Where the scenario takes place")
    time_context: str = Field(default="", description="When/what situation")
    atmosphere: str = Field(default="", description="Detailed mood/atmosphere description")
    plot_hooks: list[str] = Field(default_factory=list, description="Key tensions/conflicts to develop")
    stakes: str = Field(default="", description="What's at risk in this scenario")
    character_goals: dict[str, str] = Field(default_factory=dict, description="{character_name: goal}")
    potential_directions: list[str] = Field(default_factory=list, description="Where the story could go")


class ScenarioCreationRequest(BaseModel):
    """Request model for interactive scenario creation with AI assistant."""

    user_message: str = Field(..., min_length=1, description="User's message about the scenario")
    current_scenario: PartialScenario = Field(default_factory=PartialScenario, description="Current partial scenario data")
    character_name: str = Field(..., min_length=1, description="Name/ID of the AI character to build scenario for")
    character_names: list[str] = Field(default_factory=list, description="All selected character IDs for multi-character scenarios")
    persona_id: str | None = Field(None, description="Optional persona ID currently selected by user")
    available_personas: list[PersonaSummary] = Field(default_factory=list, description="List of available personas for AI to suggest from")
    conversation_history: list[ChatMessageModel] = Field(default_factory=list, description="Previous conversation messages for context")
    processor_type: str = Field(default="claude", description="AI processor type to use")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type")


class ScenarioCreationStreamEvent(BaseModel):
    """Stream event for interactive scenario creation."""

    type: str = Field(..., description="Event type: 'message', 'update', 'complete', 'error'")
    message: str | None = Field(None, description="AI message chunk to show in chat")
    updates: PartialScenario | None = Field(None, description="Updated scenario state with current values")
    error: str | None = Field(None, description="Error message if type is 'error'")


class SaveScenarioRequest(BaseModel):
    """Request model for saving a completed scenario."""

    scenario: Scenario = Field(..., description="The scenario to save")
    scenario_id: str | None = Field(None, description="Optional scenario ID (generated if not provided)")


class SaveScenarioResponse(BaseModel):
    """Response model for saving a scenario."""

    scenario_id: str = Field(..., description="The saved scenario's ID")
    message: str = Field(default="Scenario saved successfully", description="Status message")


class ScenarioSummary(BaseModel):
    """Summary model for scenario listing with minimal data."""

    id: str = Field(..., description="Scenario ID")
    summary: str = Field(..., description="Scenario title/summary")
    narrative_category: str = Field(..., description="Genre/tone label")
    character_id: str = Field(..., description="Associated character ID")
    character_ids: list[str] = Field(default_factory=list, description="All scenario characters")
    character_tags: list[str] = Field(default_factory=list, description="Character tags used for cast selection")
    ruleset_id: str = Field(default="everyday-tension", description="Ruleset ID used by this scenario")
    world_lore_id: str | None = Field(default=None, description="Optional world lore ID")
    world_lore_tags: list[str] = Field(default_factory=list, description="World lore tags used for context selection")
    created_at: str = Field(..., description="Creation timestamp")
    updated_at: str = Field(..., description="Last update timestamp")


class ListScenariosResponse(BaseModel):
    """Response model for listing scenarios."""

    character_name: str = Field(..., description="Name of the character")
    scenarios: list[ScenarioSummary] = Field(..., description="List of scenario summaries")


class WorldLoreAsset(BaseModel):
    id: str = Field(..., description="World lore ID")
    name: str = Field(..., description="Display name")
    lore_text: str = Field(..., description="Main world lore text")
    tags: list[str] = Field(default_factory=list, description="Tags for UI filtering and categorization")
    keywords: list[str] = Field(default_factory=list, description="Search-oriented keywords for future dynamic retrieval")
    lore_json: dict | None = Field(default=None, description="Optional structured metadata")
    created_at: str = Field(..., description="Creation timestamp")
    updated_at: str = Field(..., description="Update timestamp")


class SaveWorldLoreRequest(BaseModel):
    name: str = Field(..., min_length=1, description="World lore name")
    lore_text: str = Field(..., min_length=1, description="World lore text content")
    tags: list[str] = Field(default_factory=list, description="Tags used for filtering and grouping")
    keywords: list[str] = Field(default_factory=list, description="Keywords used for future search indexing")
    lore_json: dict | None = Field(default=None, description="Optional structured metadata")
    world_lore_id: str | None = Field(default=None, description="Optional ID for update")


class SaveWorldLoreResponse(BaseModel):
    world_lore_id: str = Field(..., description="Saved world lore ID")
    message: str = Field(default="World lore saved successfully", description="Status message")


class PartialWorldLore(BaseModel):
    name: str = Field(default="", description="World lore display name")
    lore_text: str = Field(default="", description="Main world lore text")
    tags: list[str] = Field(default_factory=list, description="Tags for filtering and categorization")
    keywords: list[str] = Field(default_factory=list, description="Keywords for retrieval/indexing")


class WorldLoreCreationRequest(BaseModel):
    user_message: str = Field(..., min_length=1, description="User's message about the world lore")
    current_world_lore: PartialWorldLore = Field(default_factory=PartialWorldLore, description="Current partial world lore data")
    conversation_history: list[ChatMessageModel] = Field(default_factory=list, description="Previous conversation messages for context")
    processor_type: str = Field(default="claude", description="AI processor type to use")
    backup_processor_type: str | None = Field(None, description="Optional backup processor type")


class WorldLoreCreationStreamEvent(BaseModel):
    type: str = Field(..., description="Event type: 'message', 'update', 'complete', 'error'")
    message: str | None = Field(None, description="AI message chunk to show in chat")
    updates: PartialWorldLore | None = Field(None, description="Updated world lore state")
    error: str | None = Field(None, description="Error message if type is 'error'")


class SessionSummaryResponse(BaseModel):
    """Response model for session summary."""

    session_id: str = Field(..., description="The session ID")
    summary_text: str = Field(..., description="Formatted summary text as it would appear in the prompt")
    has_summary: bool = Field(..., description="Whether the session has any summaries")


class RulesetDefinition(BaseModel):
    """Ruleset metadata and schema definition for ruleset-aware forms."""

    id: str = Field(..., description="Ruleset ID")
    name: str = Field(..., description="Display name")
    rulebook_text: str = Field(..., description="Ruleset rulebook text")
    character_stat_schema: dict = Field(default_factory=dict, description="Schema for character stat blocks")
    scene_state_schema: dict = Field(default_factory=dict, description="Schema for scene state")
    mechanics_guidance: dict | None = Field(default=None, description="Optional mechanics metadata")
